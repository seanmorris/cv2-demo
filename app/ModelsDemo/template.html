<div class="models-demo">

	<h2>models</h2>

	<p>Models are simple objects, with some light tooling to make them simple to populate. They will also use the <b>class</b> and <b>id</b> properties to ensure that each model only gets a single reference. If you load the same model multiple times, the input fields should remain synced.</p>

	<div class = "row wrap">

		<div class = "model-editor model-loader">

			<div class = "model-editor-title">
				<span class = "title">Model Loader</span>
				<span class = "buttons">✕</span>
			</div>

			<div class = "model-editor-eyebrow">Load an instance of a record with the given ID and type. If no record is found, one will be created.</div>

<pre>model = Model.from({
<div class = "property-edit"><span>  id: </span><input type = "number" cv-bind = "newId" />,</div>
<div class = "property-edit"><span>  class: </span><input cv-bind = "newClass" />,</div>});</pre>
			<div class = "buttons">
				<button cv-on = "click:loadModel">load</button>
			</div>

		</div>
		<div cv-each = "models:model:m" cv-ref = "models" class = "contents">
			<div class = "model-editor [[saving]]">

				<div class = "model-editor-title">
					<span class = "title">Model Editor</span>
					<span class = "buttons">
						<span tabindex="-1" cv-on = "click:closeModel(event, m)">✕</span>
					</span>
				</div>

				<div class = "model-editor-eyebrow">When you modify the properties below, the in-memory values will be updated as you type.</div>

				<div class = "model-editor-body">

					<div cv-each = "stores:store:s" class = "database-store-selector">
						<div cv-on = "click:storeModel(event, model, store, $parent)">[[store]]</div>
					</div>

<pre><span class = "firstline row">model = { <img src = "/save.svg" cv-on = "click:showModelStores(event, $subview)" data-icon tabindex="-1"></span>
<div cv-each = "model:value:property"><div class = "property-edit"><span class = "prop-remove remove-[[property]]" cv-on = "click:removeKey(property, m);">  ✕ </span> [[property]]: <input data-property = "[[property]]" cv-bind = "value" cv-on = "cvDomAttached:fieldAttached(event)" />,
</div></div>};</pre>

					<div class = "model-editor-text">Add a new key:</div>

					<div class = "new-property">
						<form class = "contents" cv-on = "submit:addKey(event, newField, m)">
							<input cv-bind = "newField" placeholder="new property">
							<button cv-on = "click:addKey(event, newField, m)" class = "tight">+</button>
						</form>
					</div>
				</div>

			</div>
		</div>

	</div>

	<h3>querying databases</h3>

	<p>Under the hood, the system uses the browser's IndexedDb system for local persistence.</p>

	<div class = "databases">

		<div class = "database-editor">
			<div class = "model-editor-title">
				Database Explorer
			</div>
			<div class = "database-editor-body">
				<div class = "database-store-list">
					<div class = "model-editor-eyebrow">
						<ul cv-each = "stores:store:s">
							<li cv-on = "click:useDb(event, store);">[[store]]</li>
						</ul>
					</div>
				</div>
				<div class = "database-editor-right">
					<form cv-on = "submit:queryDatabase(event)">
						<label>index: <select cv-bind = "queryIndex" cv-each = "queryIndexes:index:i">
							<option value="[[index]]">[[index]]</option>
						</select></label>
						<label>value: <input cv-bind = "queryValue" /></label>
						<label>limit: <input type = "number" cv-bind = "queryLimit" /></label>
						<input type = "hidden" readonly="readonly" cv-bind = "queryStore" />
						<label class = "buttons">
							<div>
								<span cv-if = "?total"> [[total]] record returned. </span>
							</div>
							<button>query</button>
						</label>
					</form>
					<div class = "tight model-scroller scroller">
						[[resultScroller]]
					</div>
				</div>
			</div>
		</div>

	</div>

	<h3>events, workers & sync</h3>

	<!-- [[editor]] -->

</div>
